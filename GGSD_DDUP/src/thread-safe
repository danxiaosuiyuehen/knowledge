线程安全（会写死锁）
线程安全问题出现的条件：
①多线程并发
②有共享数据
③共享数据有修改行为

线程同步机制来保证数据的安全
做法一：在对共享对象的共享数据进行修改的方法中加上synchronized（共享对象）｛对共享数据进行修改的行为的代码块｝
做法二：在实例方法上使用synchronized，这样的话默认共享对象是this（当前对象），原先大括号中的代码块现在默认是整个方法体使用线程同步，相比做法一效率低

同样在方法的public后加synchronized，但是该方法上静态方法的话，不管new了几个对象，该类中的所以方法都需要排队，该锁属于类锁。上面两个属于方法锁。
这里有个锁的概念，即每个对象都对应一把锁，当某个线程对共享对象的数据进行操作时，就占用了这个对象的锁，下一个线程想对该对象操作时，发现有synchronized，就去找对象锁，发现该对象锁被占用就会去锁池中等待，该线程也会由运行状态变成阻塞状态，当，前一个线程释放了对象锁，该线程会变成就绪状态然后由它来占用锁并运行

做法三：实现callable接口（该做法可以接收到其他线程的返回值）但是正因为它需要接收其他线程返回值导致必须等其他线程执行完成才能继续执行，所以非必须要返回值不使用该方法。
代码：new 一个futuretask对象，形参传实现了callable接口的对象（实现了callable接口的类就相当于另一个线程，该类有返回值）。
再new一个thread对象，把futuretask对象传入形参，然后启动线程，用futuretask对象调用get方法可以接收到callable接口的实现类的返回结果。

实例变量   静态变量   局部变量中
局部变量永远不会存在线程安全问题，因为局部变量都在对应的线程中，不共享。
方法区和堆内存是共享的，所以实例变量和静态变量（成员变量）才会存在线程安全问题
如何避免线程安全问题：尽可能使用局部变量（servlet就是这样处理的），每个线程给一个对应对象

一个线程往list集合中放元素，一个线程取元素，让两线程均衡，使用wait和notify以及synchronized。