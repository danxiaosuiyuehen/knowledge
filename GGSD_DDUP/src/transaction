本地事务以及分布式事务
事务：ACID 原子性 一致性 隔离性 持久性
隔离性：读未提交（脏读） 读已提交（不可重复读，如：mysql数据库） 可重复读（幻读，如：oracle）  序列化读/串行化（serializable）
数据库事务：数据库本身就带有事务，所以可以叫数据库事务
本地事务：同一台服务器上运行的关系型数据库的事务，叫本地事务
分布式事务产生的场景：跨服务（不同的虚拟机）调用和跨数据库的操作 例如：A服务去调B服务时，A和B服务的对数据库的操作都成功了，A向B转账，
                    A账户减少了，B账户也增加了，但是在准备提交时，AB间由于网络挂掉了，而导致A就会回滚，而B提交，产生数据的不一致。
CAP：
一致性(Consistency)：实现方式 主数据库写入数据时，从数据库锁定
可用性(Availability)：实现方式 主数据库写入数据时，从数据库不能锁定
分区容错性(Partition tolerance)：实现方式 1.用异步代替同步 2.添加从数据库节点       TODO
base理论：
基本可用（Basically Available）
软状态（Soft State）
最终一致性（Eventually Consistent）

分布式事务的最终解决
2PC协议：两阶段提交协议（MySQL和oracle都支持该协议）或者叫XA（ 事务管理器（TM）资源管理器（RM）的接口规范）又叫阻塞协议
    P：准备阶段  事务管理器给两服务发送prepare指令，记录Undo日志，两服务各自执行自己的事务，记录Redo日志
    C：提交阶段  事务失败或者超时则发送rollback指令，否则发送commit指令 在最后释放事务处理过程中使用的锁资源
    主要用到 事务管理器（TM）资源管理器（RM）和Undo日志(记录修该前的数据) Redo日志(记录修改后的数据)
    弊端：调用方和被调用方在执行是都被锁住

seata（是XA的升级：调用方先提交并释放锁，被调用方提交并释放锁，） ：当事务代码实现过于复杂，为避免长期占用锁定数据库，不能使用
    TM 事务管理器 TC 事务协调器 RM 资源管理器
    TC单独部署，需要修改TC的file和registed文件，创建datesourceproxy文件并在application.properties配置数据源
    资源管理器会记录undo和redo日志，我们需要在数据库建一张 undo_log 表，异常时会在表中打印修改前后的数据，成功会删除日志。
    怎么保证是同一个事务？怎么保证TC断电不影响？
    事务管理器的XID和各资源管理器的关联XID的分支ID
    有undo_log日志

TCC 当事务代码实现过于复杂，为避免长期占用锁定数据库，不能使用
当时课程19年3月份在springcloud中seata对TCC是不支持的（现在是支持的），所以用的Hmily框架，该框架基于TCC原理
TCC之Hmily：支持事务的嵌套
Try：预留业务资源（记录原始数据库数据）
Confirm：确认执行业务操作，提交
Cancel：取消执行业务操作，回滚

TCC的三大异常处理
空回滚：该服务没有try，自然也没有预留资源，TM以为try了，所以try刚开始时加日志，判断有无日志来进行回滚与否。
幂等：
空先挂：

可靠消息最终一致性（rocketMQ的事务机制，收费，还挺贵   回查机制）无法回滚

最大努力通知  无法回滚






